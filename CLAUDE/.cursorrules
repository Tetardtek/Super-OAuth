# SuperOAuth - RÃ¨gles pour les Agents IA (Cursor, Claude Code, etc.)

## ğŸ¯ Objectif du Projet

SuperOAuth est un systÃ¨me d'authentification OAuth moderne construit avec TypeScript, Express, et TypeORM, suivant les principes du Domain-Driven Design (DDD) et de l'Architecture Hexagonale.

## ğŸ“ Architecture

- **Domain-Driven Design (DDD)** avec sÃ©paration en couches
- **Clean Architecture** avec dÃ©pendances inversÃ©es
- **SOLID Principles** strictement appliquÃ©s
- **TypeScript Strict Mode** sans exceptions

### HiÃ©rarchie des Couches

```
Presentation â†’ Application â†’ Domain â† Infrastructure
```

**RÃ¨gle d'or:** Les dÃ©pendances pointent TOUJOURS vers le Domain, jamais l'inverse.

## ğŸš« Interdictions Strictes

### 1. Ne JAMAIS court-circuiter les couches

âŒ **INTERDIT:**
```typescript
// Controller accÃ©dant directement au repository
class AuthController {
  constructor(private userRepo: UserRepository) {}
}

// Use Case accÃ©dant directement Ã  TypeORM
class LoginUseCase {
  async execute() {
    const user = await getRepository(User).findOne(...);
  }
}
```

âœ… **OBLIGATOIRE:**
```typescript
// Controller utilisant un Use Case
class AuthController {
  constructor(private loginUseCase: LoginClassicUseCase) {}
}

// Use Case utilisant une interface de repository
class LoginUseCase {
  constructor(private userRepository: IUserRepository) {}
}
```

### 2. Ne JAMAIS utiliser 'any'

âŒ Interdit: `const data: any`
âœ… Utiliser: `unknown`, types spÃ©cifiques, ou gÃ©nÃ©riques

### 3. Ne JAMAIS mettre de logique mÃ©tier dans les Controllers

Les controllers sont des **adaptateurs HTTP uniquement**.

### 4. Ne JAMAIS hardcoder de valeurs

âŒ `if (user.role === 'admin')`
âœ… `if (user.role === UserRole.ADMIN)` avec enum/const

## âœ… RÃ¨gles Obligatoires

### 1. TypeScript Strict

Tous les fichiers doivent compiler en mode strict:
```typescript
// Activer dans tsconfig.json
"strict": true,
"noImplicitAny": true,
"strictNullChecks": true,
"noUnusedLocals": true,
"noUnusedParameters": true
```

### 2. Utiliser les Alias d'Imports

```typescript
âœ… import { User } from '@domain/entities/user.entity';
âœ… import { RegisterDto } from '@application/dto/auth.dto';
âœ… import { logger } from '@shared/utils/logger.util';

âŒ import { User } from '../../../domain/entities/user.entity';
```

### 3. Injection de DÃ©pendances

Toujours injecter les dÃ©pendances via le constructeur:

```typescript
export class RegisterClassicUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly passwordHasher: IPasswordHasher,
    private readonly emailService: IEmailService
  ) {}
}
```

### 4. Gestion d'Erreurs MÃ©tier

CrÃ©er des erreurs spÃ©cifiques dans `domain/errors/`:

```typescript
export class UserAlreadyExistsError extends Error {
  constructor(email: string) {
    super(`User with email ${email} already exists`);
    this.name = 'UserAlreadyExistsError';
  }
}
```

### 5. Logging

Utiliser le logger Winston pour toutes les opÃ©rations importantes:

```typescript
logger.info('User registered successfully', { userId: user.id });
logger.error('Registration failed', { error: error.message, email });
logger.warn('Suspicious login attempt', { ip, userAgent });
logger.debug('Token validation details', { token, expiry });
```

### 6. Validation

- **RequÃªtes HTTP:** Utiliser les validators Joi dans `presentation/validators/`
- **Value Objects:** Valider dans le constructeur
- **DTOs:** DÃ©finir dans `application/dto/`

## ğŸ“ Structure des Fichiers

### Conventions de Nommage

| Type | Pattern | Exemple |
|------|---------|---------|
| Entity | `{name}.entity.ts` | `user.entity.ts` |
| Use Case | `{verb}-{noun}.use-case.ts` | `register-classic.use-case.ts` |
| Repository | `{entity}.repository.ts` | `user.repository.ts` |
| Repository Interface | `{entity}.repository.interface.ts` | `user.repository.interface.ts` |
| Controller | `{entity}.controller.ts` | `auth.controller.ts` |
| Service | `{name}.service.ts` | `email.service.ts` |
| DTO | `{context}.dto.ts` | `auth.dto.ts` |
| Value Object | `{name}.vo.ts` | `email.vo.ts` |
| Error | `{context}-errors.ts` | `user-errors.ts` |
| Middleware | `{name}.middleware.ts` | `auth.middleware.ts` |

### Organisation par Couche

```
src/
â”œâ”€â”€ domain/              # Logique mÃ©tier pure (pas de dÃ©pendances externes)
â”‚   â”œâ”€â”€ entities/       # EntitÃ©s du domaine
â”‚   â”œâ”€â”€ value-objects/  # Objets valeur immuables
â”‚   â”œâ”€â”€ repositories/   # Interfaces des repositories
â”‚   â””â”€â”€ errors/         # Erreurs mÃ©tier
â”‚
â”œâ”€â”€ application/         # Orchestration des use cases
â”‚   â”œâ”€â”€ use-cases/      # Cas d'utilisation mÃ©tier
â”‚   â”œâ”€â”€ dto/            # Data Transfer Objects
â”‚   â”œâ”€â”€ services/       # Services applicatifs
â”‚   â””â”€â”€ interfaces/     # Interfaces
â”‚
â”œâ”€â”€ infrastructure/      # ImplÃ©mentations concrÃ¨tes
â”‚   â”œâ”€â”€ database/       # TypeORM, repositories, migrations
â”‚   â”œâ”€â”€ oauth/          # Providers OAuth
â”‚   â”œâ”€â”€ services/       # Services externes (email, SMS, etc.)
â”‚   â””â”€â”€ di/             # Dependency Injection container
â”‚
â”œâ”€â”€ presentation/        # Couche HTTP/REST
â”‚   â”œâ”€â”€ controllers/    # ContrÃ´leurs Express
â”‚   â”œâ”€â”€ routes/         # DÃ©finition des routes
â”‚   â”œâ”€â”€ middleware/     # Middlewares HTTP
â”‚   â””â”€â”€ validators/     # Validation Joi
â”‚
â””â”€â”€ shared/              # Code partagÃ©
    â”œâ”€â”€ config/         # Configuration
    â”œâ”€â”€ utils/          # Utilitaires
    â”œâ”€â”€ types/          # Types globaux
    â””â”€â”€ constants/      # Constantes
```

## ğŸ”§ Ajout de FonctionnalitÃ©s

### Workflow pour Ajouter une Feature

1. **Analyser la demande**
   - Identifier la couche concernÃ©e
   - VÃ©rifier les dÃ©pendances existantes
   - Lire les fichiers liÃ©s

2. **CrÃ©er les composants dans l'ordre**
   - Domain (Entities, Value Objects, Errors)
   - Application (Use Cases, DTOs)
   - Infrastructure (Repositories, Services)
   - Presentation (Controllers, Routes, Validators)

3. **Ã‰crire les tests**
   - Tests unitaires pour les Use Cases
   - Tests d'intÃ©gration pour les Controllers
   - Viser 85%+ de couverture

4. **Documentation**
   - JSDoc pour les fonctions publiques
   - Commentaires pour la logique complexe
   - Mise Ã  jour du README si nÃ©cessaire

### Exemple: Ajouter un Provider OAuth

```typescript
// 1. Domain: Ajouter le provider dans les types
// src/shared/types/oauth.types.ts
export type OAuthProvider = 'discord' | 'google' | 'github' | 'twitch' | 'linkedin';

// 2. Infrastructure: CrÃ©er le provider
// src/infrastructure/oauth/providers/linkedin.provider.ts
export class LinkedInOAuthProvider implements IOAuthProvider {
  getAuthorizationUrl(): string { ... }
  handleCallback(code: string): Promise<OAuthUserInfo> { ... }
}

// 3. Infrastructure: Enregistrer dans la factory
// src/infrastructure/oauth/oauth-provider.factory.ts
case 'linkedin':
  return new LinkedInOAuthProvider();

// 4. Application: Le Use Case existant fonctionne automatiquement
// Aucune modification nÃ©cessaire grÃ¢ce Ã  l'interface IOAuthProvider

// 5. Presentation: Ajouter la route
// src/presentation/routes/oauth.routes.ts
router.get('/oauth/linkedin', oauthController.startOAuth);
router.get('/oauth/linkedin/callback', oauthController.completeOAuth);

// 6. Config: Ajouter les variables d'environnement
// .env.example
LINKEDIN_CLIENT_ID=your_client_id
LINKEDIN_CLIENT_SECRET=your_client_secret
```

## ğŸ§ª Tests

### RÃ¨gles de Test

1. **Un test = Un comportement**
2. **Pattern AAA:** Arrange, Act, Assert
3. **Noms descriptifs:** `should_{behavior}_when_{condition}`
4. **Mocker les dÃ©pendances externes**
5. **Tester les cas limites et erreurs**

### Structure d'un Test

```typescript
describe('RegisterClassicUseCase', () => {
  let useCase: RegisterClassicUseCase;
  let mockUserRepository: jest.Mocked<IUserRepository>;
  let mockPasswordHasher: jest.Mocked<IPasswordHasher>;

  beforeEach(() => {
    // Arrange - Setup des mocks
    mockUserRepository = {
      findByEmail: jest.fn(),
      save: jest.fn(),
    } as any;

    mockPasswordHasher = {
      hash: jest.fn(),
    } as any;

    useCase = new RegisterClassicUseCase(
      mockUserRepository,
      mockPasswordHasher
    );
  });

  it('should_register_user_when_email_not_exists', async () => {
    // Arrange
    const dto = { email: 'test@example.com', password: 'Pass123!' };
    mockUserRepository.findByEmail.mockResolvedValue(null);
    mockPasswordHasher.hash.mockResolvedValue('hashed_password');

    // Act
    const result = await useCase.execute(dto);

    // Assert
    expect(result).toBeDefined();
    expect(mockUserRepository.save).toHaveBeenCalledTimes(1);
  });

  it('should_throw_error_when_user_already_exists', async () => {
    // Arrange
    const dto = { email: 'test@example.com', password: 'Pass123!' };
    mockUserRepository.findByEmail.mockResolvedValue({} as User);

    // Act & Assert
    await expect(useCase.execute(dto)).rejects.toThrow(UserAlreadyExistsError);
  });
});
```

## ğŸ” SÃ©curitÃ©

### Checklist SÃ©curitÃ©

- [ ] Mots de passe TOUJOURS hachÃ©s (bcrypt)
- [ ] Validation stricte des entrÃ©es (Joi)
- [ ] Pas de donnÃ©es sensibles dans les logs
- [ ] Tokens JWT avec expiration courte
- [ ] Rate limiting sur les endpoints sensibles
- [ ] CORS configurÃ© correctement
- [ ] Helmet pour les headers HTTP
- [ ] Protection CSRF avec state token (OAuth)
- [ ] Sanitisation des donnÃ©es utilisateur
- [ ] Pas de secrets dans le code (utiliser .env)

### DonnÃ©es Sensibles

âŒ **JAMAIS logger:**
- Mots de passe
- Tokens JWT complets
- Refresh tokens
- Secrets OAuth

âœ… **Peut logger:**
- User ID
- Email (masquÃ©: `u***@example.com`)
- IP (partielle: `192.168.x.x`)
- Actions utilisateur

## ğŸ“Š Performance

### Optimisations

1. **RequÃªtes Database**
   - Utiliser les relations TypeORM
   - Ã‰viter les N+1 queries
   - Ajouter des index sur les colonnes frÃ©quemment recherchÃ©es

2. **Caching**
   - Redis pour les sessions
   - Cache les donnÃ©es peu changeantes
   - Invalider le cache intelligemment

3. **Async/Await**
   - ParallÃ©liser les opÃ©rations indÃ©pendantes
   - Utiliser `Promise.all()` quand possible

## ğŸ¨ Formatage et Style

### Prettier Configuration

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}
```

### ESLint Rules

- Pas de variables non utilisÃ©es
- Pas d'imports non utilisÃ©s
- PrÃ©fÃ©rer `const` Ã  `let`
- Pas de `console.log` (utiliser logger)

## ğŸ“ Documentation Code

### JSDoc pour Fonctions Publiques

```typescript
/**
 * Registers a new user with email and password
 *
 * @param dto - User registration data containing email, password, and nickname
 * @returns Promise resolving to the created user entity
 * @throws {UserAlreadyExistsError} When email is already registered
 * @throws {InvalidPasswordError} When password doesn't meet requirements
 *
 * @example
 * ```typescript
 * const user = await registerUseCase.execute({
 *   email: 'user@example.com',
 *   password: 'SecurePass123!',
 *   nickname: 'JohnDoe'
 * });
 * ```
 */
async execute(dto: RegisterDto): Promise<User> {
  // Implementation
}
```

## ğŸ”„ Git Commits

### Format

```
type(scope): description

[optional body]
[optional footer]
```

### Types

- `feat`: Nouvelle fonctionnalitÃ©
- `fix`: Correction de bug
- `refactor`: Refactoring sans changement fonctionnel
- `docs`: Documentation
- `test`: Tests
- `chore`: Maintenance (deps, config)
- `perf`: Performance
- `style`: Formatage

### Exemples

```bash
feat(auth): add LinkedIn OAuth provider
fix(session): resolve token expiration issue
refactor(user): extract email validation to value object
docs(api): update authentication endpoints
test(auth): add unit tests for register use case
```

## ğŸš€ Avant de Commiter

```bash
# 1. VÃ©rifier le build TypeScript
npm run build

# 2. Lancer les tests
npm run test

# 3. VÃ©rifier la couverture
npm run test:coverage

# 4. Formater le code
npm run format

# 5. Linter
npm run lint:fix

# 6. VÃ©rifier les types
npm run typecheck
```

## ğŸ“š Fichiers Importants Ã  Consulter

Avant toute modification, consulter:

1. `ARCHITECTURE.md` - Architecture dÃ©taillÃ©e du projet
2. `CONTRIBUTING.md` - Guide de contribution complet
3. `AI_AGENT_GUIDE.md` - Instructions spÃ©cifiques pour agents IA
4. `PROJECT_STRUCTURE.md` - Structure dÃ©taillÃ©e des fichiers
5. `README.md` - Documentation gÃ©nÃ©rale

## ğŸ¤– Instructions pour Agents IA

### Workflow de Travail

1. **Toujours lire avant d'Ã©crire**
   - Comprendre le contexte
   - Identifier les dÃ©pendances
   - VÃ©rifier l'architecture existante

2. **Analyser l'impact**
   - Quelles couches sont affectÃ©es?
   - Y a-t-il des breaking changes?
   - Les tests doivent-ils Ãªtre mis Ã  jour?

3. **ImplÃ©menter progressivement**
   - Une couche Ã  la fois
   - Tester au fur et Ã  mesure
   - Documenter les changements

4. **Valider le rÃ©sultat**
   - Les tests passent
   - Le code compile
   - La qualitÃ© est maintenue

### Questions Ã  se Poser

- âœ… Est-ce que je respecte la sÃ©paration des couches?
- âœ… Est-ce que j'utilise l'injection de dÃ©pendances?
- âœ… Est-ce que mes erreurs sont typÃ©es et explicites?
- âœ… Est-ce que je log les opÃ©rations importantes?
- âœ… Est-ce que mon code est testÃ©?
- âœ… Est-ce que la sÃ©curitÃ© est prÃ©servÃ©e?

## ğŸ¯ Objectifs de QualitÃ©

- **Couverture de tests:** 85%+
- **ComplexitÃ© cyclomatique:** < 10 par fonction
- **Duplication de code:** < 3%
- **Taille des fichiers:** < 300 lignes
- **Taille des fonctions:** < 50 lignes

---

**En cas de doute, TOUJOURS privilÃ©gier:**
- La clartÃ© sur la concision
- La sÃ©curitÃ© sur la performance
- La maintenabilitÃ© sur l'optimisation prÃ©maturÃ©e
- Les tests sur le code de production
